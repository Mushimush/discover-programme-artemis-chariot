<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ESP32-CAM Detection Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #fff;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 18px;
            font-weight: normal;
            color: #888;
        }
        #container {
            position: relative;
            display: inline-block;
        }
        #stream {
            display: block;
            background: #000;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        #info {
            margin-top: 10px;
            font-family: monospace;
            font-size: 14px;
            color: #0f0;
        }
        #status {
            color: #888;
            font-size: 12px;
            margin-top: 5px;
        }
        .error { color: #f55; }
        .connected { color: #0f0; }
    </style>
</head>
<body>
    <h1>ESP32-CAM Detection Viewer</h1>
    <div id="container">
        <img id="stream" width="320" height="240" alt="Stream loading...">
        <canvas id="overlay" width="320" height="240"></canvas>
    </div>
    <div id="info">Waiting for detection...</div>
    <div id="status">Connecting...</div>

    <script>
        // Configuration - change this to your ESP32-CAM IP
        const ESP32_IP = '192.168.68.61';
        const STREAM_URL = `http://${ESP32_IP}/stream`;
        const DETECTION_URL = `http://${ESP32_IP}/detection`;

        const stream = document.getElementById('stream');
        const canvas = document.getElementById('overlay');
        const ctx = canvas.getContext('2d');
        const infoDiv = document.getElementById('info');
        const statusDiv = document.getElementById('status');

        let detection = null;
        let fetchCount = 0;
        let lastDetectionTime = Date.now();

        // Start/restart stream with cache busting
        function startStream() {
            stream.src = STREAM_URL + '?t=' + Date.now();
            statusDiv.textContent = 'Connecting...';
            statusDiv.className = '';
        }

        stream.onload = () => {
            canvas.width = stream.naturalWidth || 320;
            canvas.height = stream.naturalHeight || 240;
            statusDiv.textContent = 'Stream connected';
            statusDiv.className = 'connected';
        };
        stream.onerror = () => {
            statusDiv.textContent = 'Stream error - reconnecting...';
            statusDiv.className = 'error';
            setTimeout(startStream, 2000);
        };

        // Monitor stream health - if no new detections for 5s, reconnect
        setInterval(() => {
            if (Date.now() - lastDetectionTime > 5000) {
                statusDiv.textContent = 'Stream stalled - reconnecting...';
                statusDiv.className = 'error';
                startStream();
            }
        }, 2000);

        startStream();

        // Fetch detection data
        async function fetchDetection() {
            try {
                const response = await fetch(DETECTION_URL);
                if (response.ok) {
                    detection = await response.json();
                    fetchCount++;
                    lastDetectionTime = Date.now();
                }
            } catch (e) {
                // Silently ignore fetch errors
            }
        }

        // Draw overlay
        function draw() {
            const w = canvas.width;
            const h = canvas.height;
            const cx = w / 2;
            const cy = h / 2;

            // Clear canvas
            ctx.clearRect(0, 0, w, h);

            // Draw center crosshair (green)
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx - 30, cy);
            ctx.lineTo(cx + 30, cy);
            ctx.moveTo(cx, cy - 30);
            ctx.lineTo(cx, cy + 30);
            ctx.stroke();

            // Center dot
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, Math.PI * 2);
            ctx.fill();

            if (detection && detection.detected) {
                const bbox = detection.bbox;
                const center = detection.center;

                // Bounding box (red)
                ctx.strokeStyle = '#f00';
                ctx.lineWidth = 2;
                ctx.strokeRect(bbox.x, bbox.y, bbox.w, bbox.h);

                // Object center (yellow with black outline)
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(center.x, center.y, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff0';
                ctx.beginPath();
                ctx.arc(center.x, center.y, 6, 0, Math.PI * 2);
                ctx.fill();

                // Line from center to object (magenta)
                ctx.strokeStyle = '#f0f';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(center.x, center.y);
                ctx.stroke();

                // Info text with shadow
                ctx.font = 'bold 16px monospace';
                ctx.fillStyle = '#000';
                ctx.fillText(`${detection.label} ${Math.round(detection.confidence * 100)}%`, 11, 26);
                ctx.fillStyle = '#fff';
                ctx.fillText(`${detection.label} ${Math.round(detection.confidence * 100)}%`, 10, 25);

                ctx.font = '14px monospace';
                ctx.fillStyle = '#000';
                ctx.fillText(`Offset: ${detection.offset.x}px  Turn: ${detection.turn_percent}%`, 11, 46);
                ctx.fillStyle = '#0ff';
                ctx.fillText(`Offset: ${detection.offset.x}px  Turn: ${detection.turn_percent}%`, 10, 45);

                ctx.fillStyle = '#000';
                ctx.fillText(detection.direction, 11, 66);
                ctx.fillStyle = '#0ff';
                ctx.fillText(detection.direction, 10, 65);

                // Update info div
                infoDiv.innerHTML = `<b>${detection.label}</b> @ ${Math.round(detection.confidence * 100)}% | ` +
                    `Offset: ${detection.offset.x}px | Turn: ${detection.turn_percent}% | ${detection.direction}`;
            } else {
                infoDiv.textContent = 'No detection';
            }

            // Frame counter
            ctx.font = '12px monospace';
            ctx.fillStyle = '#666';
            ctx.fillText(`F:${fetchCount}`, w - 50, 15);

            requestAnimationFrame(draw);
        }

        // Start fetching detection every 200ms
        setInterval(fetchDetection, 200);

        // Start drawing
        draw();
    </script>
</body>
</html>
